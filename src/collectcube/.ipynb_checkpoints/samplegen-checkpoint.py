{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c441af2",
   "metadata": {},
   "outputs": [],
   "source": [
    "#!/usr/bin/env python\n",
    "# coding: utf-8\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import random\n",
    "from pathlib import Path\n",
    "import osgeo  #Needed for use on Windows only\n",
    "#from osgeo import gdal\n",
    "#import shapely\n",
    "from shapely.geometry import Point, Polygon \n",
    "import numpy as np\n",
    "import geopandas as gpd\n",
    "import pandas as pd\n",
    "import rasterio as rio\n",
    "from rasterio import plot\n",
    "from rasterio.plot import show\n",
    "#import xarray\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "def get_sample_in_poly(aoi_in, sampsize):\n",
    "    gdf = gpd.read_file(aoi_in)\n",
    "    print('poly file has crs:{}'.format(gdf.crs))\n",
    "\n",
    "    # find area bounds\n",
    "    bounds = gdf.geometry.total_bounds\n",
    "    print(bounds)\n",
    "    xmin, ymin, xmax, ymax = bounds\n",
    "\n",
    "    xext = xmax - xmin\n",
    "    yext = ymax - ymin\n",
    "\n",
    "    points = []\n",
    "    while len(points) < sampsize:\n",
    "        # generate a random x and y\n",
    "        x = xmin + random.random() * xext\n",
    "        y = ymin + random.random() * yext                                 \n",
    "        p = Point(x, y)\n",
    "        if gdf.geometry.contains(p).any():  # check if point is inside geometry\n",
    "            points.append(p)\n",
    "    \n",
    "    #gs = gpd.GeoSeries(points)\n",
    "    ptgdf = gpd.GeoDataFrame(geometry=gpd.GeoSeries(points), crs=gdf.crs)\n",
    "    return ptgdf\n",
    "\n",
    "def move_points_to_pixel_centroids(ptgdf, ref_ras, write_pts=False ptsout=None):\n",
    "    '''\n",
    "    ## With GDAL only:\n",
    "    driver = gdal.GetDriverByName('GTiff')\n",
    "    ds = gdal.Open(ref_ras)\n",
    "    transform = ref_ras.GetGeoTransform()\n",
    "    x_origin = transform[0]\n",
    "    y_origin = transform[3]\n",
    "    pixel_width = transform[1]\n",
    "    pixel_height = -transform[5]\n",
    "    crs = ref_ras.GetProjection()\n",
    "    print('ref_ras has crs:{}'.format(crs))\n",
    "    print(transform)\n",
    "    # e.g: (3158725.0, 10.0, 0.0, -3159495.0, 0.0, -10.0)\n",
    "    '''\n",
    "    with rio.open(ref_ras) as src:\n",
    "        img = src.read()\n",
    "    x_origin = src.transform[2]\n",
    "    y_origin = src.transform[5]\n",
    "    pixel_width = src.transform[0]\n",
    "    pixel_height = -src.transform[4]\n",
    "    print('ref_ras has crs:{}'.format(src.crs))\n",
    "    #print(src.transform)\n",
    "    shifted_pts = []\n",
    "    \n",
    "    if ptgdf.crs != src.crs:\n",
    "        ptgdf = ptgdf.to_crs(src.crs)\n",
    "        \n",
    "    for index,row in ptgdf.iterrows():\n",
    "        point = (row.geometry.x, row.geometry.y)\n",
    "        col = int((point[0] - x_origin) / pixel_width)\n",
    "        row = int((y_origin - point[1] ) / pixel_height)\n",
    "        pixel_centroid = Point(x_origin + (pixel_width*col) + (pixel_width/2), y_origin - (pixel_height*row) - (pixel_height/2))\n",
    "        shifted_pts.append(pixel_centroid)\n",
    "        \n",
    "    #gs_shift = gpd.GeoSeries(shifted_pts)\n",
    "    ptgdf_shift = gpd.GeoDataFrame(geometry=gpd.GeoSeries(shifted_pts),crs=src.crs)\n",
    "\n",
    "    if write_pts=True:\n",
    "        ptgdf_shift.to_file(ptsout, driver='ESRI Shapefile')\n",
    "        \n",
    "    return ptgdf_shift\n",
    "\n",
    "def plot_poly_on_index(zoom_poly, img, poly_file):\n",
    "    '''\n",
    "    Plots a polygon file {'poly_file'} on top of a .tiff image {'img'}\n",
    "    and zooms to a selected poly {'zoom_poly'}\n",
    "    '''\n",
    "    fig, ax = plt.subplots(figsize=(12,12))\n",
    "    polys = gpd.read_file(poly_file)\n",
    "    \n",
    "    #Get bounds to zoom into polygon specified in arguments\n",
    "    polybds = polys.query(f'FID == {zoom_poly}').bounds\n",
    "    minx=int((polybds['minx'][1])-100)\n",
    "    maxx=int((polybds['maxx'][1])+100)\n",
    "    miny=int((polybds['miny'][1])-100)\n",
    "    maxy=int((polybds['maxy'][1])+100)\n",
    "\n",
    "    plt.axis([minx,maxx,miny,maxy])\n",
    "    \n",
    "    if img.endswith('.tif'):\n",
    "        with rio.open(img) as src:\n",
    "            img = src.read()\n",
    "    elif img.endswith('.nc'):\n",
    "        with xr.open_dataset(img) as xrimg:\n",
    "            xr_band = xrimg.nir\n",
    "            img = xr_band.where(xr_band < 10000)\n",
    "        img.plot(x=\"x\",y=\"y\")\n",
    "\n",
    "    plot.show(img, ax=ax)\n",
    "    polys.plot(ax=ax, facecolor='none', edgecolor='orangered')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:anaconda3-venv.pheno]",
   "language": "python",
   "name": "conda-env-anaconda3-venv.pheno-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
